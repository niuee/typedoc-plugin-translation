{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { Application, ParameterType, Converter, Context, DefaultThemeRenderContext, ProjectReflection, ReflectionKind, Reflection, Models} from \"typedoc\";\nimport crypto from 'crypto';\nimport { writeFileSync, mkdirSync, readFileSync, existsSync, cpSync } from \"node:fs\";\nimport { resolve } from \"node:path\";\n\nconst reflectionKind = ReflectionKind;\n\nexport function load(app: Application) {\n    app.options.addDeclaration({\n        name: \"l10nCode\",\n        help: \"The language code for the generating translation json file\",\n        type: ParameterType.String,\n        defaultValue: \"en\",\n    });\n\n    app.options.addDeclaration({\n        name: \"translationMode\",\n        help: \"The translation mode for generating or injecting the translation jsons\",\n        type: ParameterType.String,\n        defaultValue: \"generate\",\n    });\n\n    app.converter.on(Converter.EVENT_END, (context: Context) => {\n        const l10nCode = app.options.getValue(\"l10nCode\") as string;\n        const mode = app.options.getValue(\"translationMode\") as string;\n        switch(mode){\n        case \"generate\":\n            app.logger.info(`Generating translation jsons for ${l10nCode}`);\n            const res = generateTranslationJSON(l10nCode, context);\n            const projectReflection = context.project;\n            for(const key in res){\n                const item = res[key];\n                const path = item.projectPath;\n                const obj = getByPath(projectReflection, path);\n                if(obj === undefined){\n                    app.logger.error(`Path not found: ${path}`);\n                }\n            }\n            break;\n        case \"inject\":\n            app.logger.info(`Injecting translation for ${l10nCode}`);\n            injectTranslation(l10nCode, context);\n            break;\n        default:\n            app.logger.info(`Generating translation jsons for ${l10nCode}`);\n            generateTranslationJSON(l10nCode, context);\n            break;\n        }\n    });\n}\n\nfunction injectTranslation(l10nCode: string, context: Context){\n    const curStagingTranslationFile = resolve(`./translations/staging/${l10nCode}`, \"translation.json\");\n    const projectReflection = context.project;\n    const res = dfs(projectReflection, []);\n    if(existsSync(curStagingTranslationFile)){\n        const curStagingTranslation = JSON.parse(readFileSync(curStagingTranslationFile, \"utf-8\")) as TranslationTrimmed;\n        const translationKeys = Object.keys(curStagingTranslation);\n        for (const key of translationKeys){\n            const curStagingItem = curStagingTranslation[key];\n            if(curStagingItem.translation !== \"\" ){\n                const item = getByPathShort(projectReflection, curStagingItem.projectPath);\n                const finalPath = curStagingItem.projectPath[curStagingItem.projectPath.length - 1];\n                if (item !== undefined){\n                    const originalText = getByPath(projectReflection, curStagingItem.projectPath);\n                    if(originalText !== undefined && curStagingItem.originalText == originalText){\n                        item[finalPath] = curStagingItem.translation;\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction generateTranslationJSON(l10nCode: string, context: Context){\n    const curStagingTranslationFile = resolve(`./translations/staging/${l10nCode}`, \"translation.json\");\n    const curProdTranslationFile = resolve(`./translations/prod/${l10nCode}`, \"translation.json\");\n    const projectReflection = context.project;\n    const res = dfs(projectReflection, []);\n    const trimmedDownData = {} as TranslationTrimmed;\n    if(existsSync(curProdTranslationFile)){\n        const curProdTranslation = JSON.parse(readFileSync(curProdTranslationFile, \"utf-8\")) as TranslationTrimmed;\n        const translationKeys = Object.keys(curProdTranslation);\n        for (const key of translationKeys){\n            const curProdItem = curProdTranslation[key];\n            if(curProdItem.translation !== \"\" && curProdItem.translationKey in res && res[curProdItem.translationKey].originalText == curProdItem.originalText){\n                res[curProdItem.translationKey].translation = curProdItem.translation;\n            }\n        }\n    }\n    if(existsSync(curStagingTranslationFile)){\n        const curStagingTranslation = JSON.parse(readFileSync(curStagingTranslationFile, \"utf-8\")) as TranslationTrimmed;\n        const translationKeys = Object.keys(curStagingTranslation);\n        for (const key of translationKeys){\n            const curStagingItem = curStagingTranslation[key];\n            if(curStagingItem.translation !== \"\" && curStagingItem.translationKey in res && res[curStagingItem.translationKey].originalText == curStagingItem.originalText){\n                res[curStagingItem.translationKey].translation = curStagingItem.translation;\n            }\n        }\n    }\n    for(const translationKey in res){\n        const item = res[translationKey];\n        const trimmedItem: TranslationItemTrimmed = {\n            humanReadablePath: item.humanReadablePath,\n            kind: item.kind,\n            originalText: item.originalText,\n            translation: item.translation,\n            projectPath: item.projectPath,\n            translationKey: item.translationKey,\n        };\n        trimmedDownData[translationKey] = trimmedItem;\n    }\n    mkdirSync(`./translations/staging/${l10nCode}`, {recursive: true});\n    writeFileSync(resolve(`./translations/staging/${l10nCode}`, \"translation.json\"), JSON.stringify(trimmedDownData, null, 2));\n    return res;\n}\n\ntype TranslationItem = {\n    originalText: string;\n    translation: string;\n    flatPath: string[];\n    projectPath: string[];\n    locationIdentifier: string;\n    translationKey: string;\n    humanReadablePath?: string;\n    kind: string;\n}\n\ntype TranslationItemTrimmed = {\n    originalText: string;\n    translation: string;\n    projectPath: string[];\n    translationKey: string;\n    humanReadablePath?: string;\n    kind: string;\n}\n\ntype Translation = {\n    [key: string]: TranslationItem;\n}\n\ntype TranslationTrimmed = {\n    [key: string]: TranslationItemTrimmed;\n}\n\nexport function reflectionMapping(node: Reflection){\n    if(node.kind == undefined){\n        return \"unknown\";\n    }\n    switch(node.kind){\n    case reflectionKind.Project:\n        return \"project\";\n    case reflectionKind.Module:\n        return \"module\";\n    case reflectionKind.Namespace:\n        return \"namespace\";\n    case reflectionKind.Enum:\n        return \"enum\";\n    case reflectionKind.EnumMember:\n        return \"enumMember\";\n    case reflectionKind.Variable:\n        return \"variable\";\n    case reflectionKind.Function:\n        return \"function\";\n    case reflectionKind.Class:\n        return \"class\";\n    case reflectionKind.Interface:\n        return \"interface\";\n    case reflectionKind.Constructor:\n        return \"constructor\";\n    case reflectionKind.Property:\n        return \"property\";\n    case reflectionKind.Method:\n        return \"method\";\n    case reflectionKind.CallSignature:\n        return \"callSignature\";\n    case reflectionKind.IndexSignature:\n        return \"indexSignature\";\n    case reflectionKind.ConstructorSignature:\n        return \"constructorSignature\";\n    case reflectionKind.Parameter:\n        return \"parameter\";\n    case reflectionKind.TypeLiteral:\n        return \"typeLiteral\";\n    case reflectionKind.TypeParameter:\n        return \"typeParameter\";\n    case reflectionKind.Accessor:\n        return \"accessor\";\n    case reflectionKind.GetSignature:\n        return \"getSignature\";\n    case reflectionKind.SetSignature:\n        return \"setSignature\";\n    case reflectionKind.TypeAlias:\n        return \"typeAlias\";\n    case reflectionKind.Reference:\n        return \"reference\";\n    default:\n        return \"unknown\";\n    }\n}\n\nexport function getCategoryStrings(node: ProjectReflection, path: string[] = [], humanReadablePath: string[] = []){\n    if (node.categories !== undefined){\n        return node.categories.map((category, index) => {\n            const flatPath = [`${node.id}`, `categories`, `index-${index}`];\n            const projectPath = [...path, \"categories\", `index-${index}`, \"title\"];\n            const translationKey = crypto.createHash('md5').update(`${projectPath.join(\"\")}${category.title}${\"category\"}`).digest('hex');\n            const locationIdentifier = crypto.createHash('md5').update(`${flatPath.join(\"\")}${category.title}${\"category\"}`).digest('hex');\n            const nextLevelHumanReadablePath = [...humanReadablePath, `categories`, `index-${index}`, \"title\"];\n            const item = { translationKey: translationKey, flatPath: flatPath, projectPath: projectPath, originalText: category.title, translation: \"\", kind: \"category\", locationIdentifier: locationIdentifier, humanReadablePath: nextLevelHumanReadablePath.join(\" > \")};\n            return item;\n        });\n    }\n    return undefined;\n}\n\ntype TranslationNode = {\n    [key: string]: Reflection;\n}\n\nfunction dfs(node: Reflection, path: string[] = [], humanReadablePath: string[] = []){\n    const res: Translation = {};\n    if((node.flags && \"isExternal\" in node.flags && node.flags.isExternal)){\n        return res;\n    }\n    if(\"categories\" in node && node.categories !== undefined){\n        const categories = getCategoryStrings(node as ProjectReflection, path, humanReadablePath);\n        if(categories !== undefined){\n            categories.forEach((category)=>{\n                res[category.translationKey] = category;\n            });\n        }\n    }\n    if(node.comment !== undefined){\n        const translations = parseTranslationComment(node, path, humanReadablePath);\n        const translationBlocks = parseTranslationBlockComment(node, path, humanReadablePath);\n        translations.forEach((translation)=>{\n            res[translation.translationKey] = translation;\n        });\n        translationBlocks.forEach((translation)=>{\n            res[translation.translationKey] = translation;\n        });\n    }\n    if(\"children\" in node){\n        const children = node.children as Reflection[];\n        children.forEach((child, index)=>{\n            const localRes = dfs(child, [...path, \"children\", `index-${index}`], [...humanReadablePath, child.name]);\n            const translationKeys = Object.keys(localRes);\n            for (const key of translationKeys){\n                res[key] = localRes[key];\n            }\n        });\n    }\n    if(\"signatures\" in node){\n        const signatures = node.signatures as Reflection[];\n        signatures.forEach((signature, index)=>{\n            const localRes = dfs(signature, [...path, \"signatures\", `index-${index}`], [...humanReadablePath, signature.name]);\n            const translationKeys = Object.keys(localRes);\n            for (const key of translationKeys){\n                res[key] = localRes[key];\n            }\n        });\n    }\n    if(\"getSignature\" in node){\n        const accessorComment = parseAccessorComment(node.getSignature as Reflection, path, node, humanReadablePath);\n        accessorComment.forEach((translationItem)=>{\n            res[translationItem.translationKey] = translationItem;\n        });\n        const getSignature = node.getSignature as Reflection;\n        const localRes = dfs(getSignature, [...path, `getSignature`], [...humanReadablePath, getSignature.name]);\n        const translationKeys = Object.keys(localRes);\n        for (const key of translationKeys){\n            res[key] = localRes[key];\n        }\n    }\n    if(\"setSignature\" in node){\n        const accessorComment = parseAccessorComment(node.setSignature as Reflection, path, node, humanReadablePath);\n        accessorComment.forEach((translationItem)=>{\n            res[translationItem.translationKey] = translationItem;\n        });\n        const setSignature = node.setSignature as Reflection;\n        const localRes = dfs(setSignature, [...path, `setSignature`], [...humanReadablePath, setSignature.name]);\n        const translationKeys = Object.keys(localRes);\n        for (const key of translationKeys){\n            res[key] = localRes[key];\n        }\n    }\n    return res;\n}\n\nfunction parseAccessorComment(node: Reflection, path: string[], parentNode: Reflection, humanReadablePath: string[] = []){\n    const translationItems: TranslationItem[] = [];\n    if (node.comment !== undefined){\n        if(parentNode.comment == undefined){\n            parentNode.comment = new Models.Comment();\n        }\n        node.comment.getTags(\"@accessorDescription\").forEach((comment)=>{\n            comment.content.forEach((content, index)=>{\n                if(content.kind !== \"text\"){\n                    return;\n                }\n                const item: TranslationItem = {\n                        originalText: content.text,\n                        translation: \"\",\n                        flatPath: [],\n                        projectPath: [],\n                        locationIdentifier: \"\",\n                        translationKey: \"\",\n                        kind: \"\"\n                    };\n                item.originalText = content.text;\n                item.translation = \"\";\n                item.flatPath = [];\n                item.flatPath.push(`${node.id}`);\n                item.flatPath.push(`${node.name}`);\n                item.flatPath.push(\"comments\");\n                item.flatPath.push(`index-${index}`);\n                const insertAtSummary = parentNode.comment.summary.length;\n                item.projectPath = [...path, \"comment\", \"summary\",`index-${insertAtSummary}`, \"text\"];\n                parentNode.comment.summary.push({...content});\n                item.kind = reflectionMapping(parentNode);\n                const locationIdentifier = crypto.createHash('md5').update(`${item.flatPath.join(\"\")}${item.originalText}${item.kind}`).digest('hex');\n                item.translationKey = crypto.createHash('md5').update(`${item.projectPath.join(\"\")}${item.originalText}${item.kind}`).digest('hex');\n                item.locationIdentifier = locationIdentifier;\n                item.humanReadablePath = [...humanReadablePath, \"accessor comments\", `index-${index}`, \"text\"].join(\" > \");\n                translationItems.push(item);\n            });\n        });\n        node.comment.removeTags(\"@accessorDescription\");\n    }\n    return translationItems;\n}\n\nfunction parseTranslationComment(node: Reflection, path: string[], humanReadablePath: string[] = []){\n    const translationItems: TranslationItem[] = [];\n    if (node.comment !== undefined){\n        node.comment.getTags(\"@translation\").forEach((comment)=>{\n            comment.content.forEach((content, index)=>{\n                if(content.kind !== \"text\"){\n                    return;\n                }\n                const item: TranslationItem = {\n                        originalText: content.text,\n                        translation: \"\",\n                        flatPath: [],\n                        projectPath: [],\n                        locationIdentifier: \"\",\n                        translationKey: \"\",\n                        kind: \"\"\n                    };\n                item.originalText = content.text;\n                item.translation = \"\";\n                item.flatPath = [];\n                item.flatPath.push(`${node.id}`);\n                item.flatPath.push(`${node.name}`);\n                item.flatPath.push(\"comments\");\n                item.flatPath.push(`index-${index}`);\n                const insertAtSummary = node.comment.summary.length;\n                item.projectPath = [...path, \"comment\", \"summary\",`index-${insertAtSummary}`, \"text\"];\n                node.comment.summary.push({...content});\n                item.kind = reflectionMapping(node);\n                const locationIdentifier = crypto.createHash('md5').update(`${item.flatPath.join(\"\")}${item.originalText}${item.kind}`).digest('hex');\n                item.translationKey = crypto.createHash('md5').update(`${item.projectPath.join(\"\")}${item.originalText}${item.kind}`).digest('hex');\n                item.locationIdentifier = locationIdentifier;\n                item.humanReadablePath = [...humanReadablePath, \"translation comments\", `index-${index}`, \"text\"].join(\" > \");\n                translationItems.push(item);\n            });\n        });\n        node.comment.removeTags(\"@translation\");\n    }\n    return translationItems;\n}\n\nfunction parseTranslationBlockComment(node: Reflection, path: string[], humanReadablePath: string[] = []){\n    const translationItems: TranslationItem[] = [];\n    if (node.comment !== undefined){\n        node.comment.blockTags.forEach((comment, blockIndex)=>{\n            if(comment.tag !== \"@translationBlock\"){\n                return;\n            }\n            comment.content.forEach((content, index)=>{\n                if(content.kind !== \"text\"){\n                    return;\n                }\n                const item: TranslationItem = {\n                    originalText: content.text,\n                    translation: \"\",\n                    flatPath: [],\n                    projectPath: [],\n                    locationIdentifier: \"\",\n                    translationKey: \"\",\n                    kind: \"\"\n                };\n                item.originalText = content.text;\n                item.translation = \"\";\n                item.flatPath = [];\n                item.flatPath.push(`${node.id}`);\n                item.flatPath.push(`${node.name}`);\n                item.flatPath.push(\"comments\");\n                item.flatPath.push(`index-${index}`);\n                item.projectPath = [...path, \"comment\", \"blockTags\",`index-${blockIndex}`, \"content\", `index-${index}`, \"text\"];\n                // const insertAtSummary = node.comment.summary.length;\n                // node.comment.summary.push(content);\n                item.kind = reflectionMapping(node);\n                const locationIdentifier = crypto.createHash('md5').update(`${item.flatPath.join(\"\")}${item.originalText}${item.kind}`).digest('hex');\n                item.translationKey = crypto.createHash('md5').update(`${item.projectPath.join(\"\")}${item.originalText}${item.kind}`).digest('hex');\n                item.locationIdentifier = locationIdentifier;\n                item.humanReadablePath = [...humanReadablePath, \"translation block comments\", `index-${index}`, \"text\"].join(\" > \");\n                translationItems.push(item);\n            });\n        });\n    }\n    return translationItems;\n}\n\nfunction reflectionClassMapping(reflection: Reflection){\n    switch(reflection.constructor.name){\n    case \"ProjectReflection\":\n        return \"project\";\n    case \"ContainerReflection\":\n        return \"container\";\n    case \"DeclarationReflection\":\n        return \"declaration\";\n    case \"ParameterReflection\":\n        return \"parameter\";\n    case \"ReferenceReflection\":\n        return \"reference\";\n    case \"TypeParameterReflection\":\n        return \"typeParameter\";\n    case \"SignatureReflection\":\n        return \"signature\";\n    default:\n        return \"reflection\";\n    }\n}\n\nexport function getByPathShort(root: any, path: string[]){\n    let obj = root;\n    for(let index = 0; index < path.length - 1; index++){\n        if(obj === undefined){\n            console.error(\"Path not found\", path);\n            return undefined;\n        }\n        if(path[index].length >= 5 && path[index].substring(0, 5) === \"index\"){\n            const indexInPath = parseInt(path[index].substring(6));\n            obj = obj[indexInPath];\n            continue;\n        }\n        if(path[index] in obj){\n            const propertyName = path[index];\n            obj = obj[propertyName];\n        }\n    }\n    return obj;\n}\n\nexport function getByPath(root: any, path: string[]){\n    let obj = root;\n    for(let index = 0; index < path.length; index++){\n        if(obj === undefined){\n            console.error(\"Path not found\", path);\n            return undefined;\n        }\n        if(path[index].length >= 5 && path[index].substring(0, 5) === \"index\"){\n            const indexInPath = parseInt(path[index].substring(6));\n            obj = obj[indexInPath];\n            continue;\n        }\n        obj = obj[path[index]];\n    }\n    return obj;\n}\n"],"names":["reflectionKind","ReflectionKind","load","app","options","addDeclaration","name","help","type","ParameterType","String","defaultValue","converter","on","Converter","EVENT_END","context","l10nCode","getValue","logger","info","res","generateTranslationJSON","projectReflection","project","key","path","projectPath","undefined","getByPath","error","curStagingTranslationFile","resolve","dfs","existsSync","curStagingTranslation","JSON","parse","readFileSync","translationKeys","Object","keys","curStagingItem","translation","item","getByPathShort","finalPath","length","originalText","injectTranslation","curProdTranslationFile","trimmedDownData","curProdTranslation","curProdItem","translationKey","trimmedItem","humanReadablePath","kind","mkdirSync","recursive","writeFileSync","stringify","reflectionMapping","node","Project","Module","Namespace","Enum","EnumMember","Variable","Function","Class","Interface","Constructor","Property","Method","CallSignature","IndexSignature","ConstructorSignature","Parameter","TypeLiteral","TypeParameter","Accessor","GetSignature","SetSignature","TypeAlias","Reference","getCategoryStrings","categories","map","category","index","flatPath","id","crypto","createHash","update","join","title","digest","locationIdentifier","nextLevelHumanReadablePath","flags","isExternal","forEach","comment","translations","translationItems","getTags","content","text","push","insertAtSummary","summary","assign","removeTags","parseTranslationComment","translationBlocks","blockTags","blockIndex","tag","parseTranslationBlockComment","children","child","localRes","signatures","signature","parseAccessorComment","getSignature","translationItem","setSignature","parentNode","Models","Comment","root","obj","console","substring","parseInt"],"mappings":"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"}