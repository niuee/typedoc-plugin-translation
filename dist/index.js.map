{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { Application, ParameterType, Converter, Context, DefaultThemeRenderContext, ProjectReflection, ReflectionKind, Reflection, Models} from \"typedoc\";\nimport crypto from 'crypto';\nimport { writeFileSync, mkdirSync, readFileSync, existsSync, cpSync } from \"node:fs\";\nimport { resolve } from \"node:path\";\n\nconst reflectionKind = ReflectionKind;\n\nexport function load(app: Application) {\n    app.options.addDeclaration({\n        name: \"l10nCode\",\n        help: \"The language code for the generating translation json file\",\n        type: ParameterType.String,\n        defaultValue: \"en\",\n    });\n\n    app.options.addDeclaration({\n        name: \"translationMode\",\n        help: \"The translation mode for generating or injecting the translation jsons\",\n        type: ParameterType.String,\n        defaultValue: \"generate\",\n    });\n\n    app.converter.on(Converter.EVENT_END, (context: Context) => {\n        const l10nCode = app.options.getValue(\"l10nCode\") as string;\n        const mode = app.options.getValue(\"translationMode\") as string;\n        switch(mode){\n        case \"generate\":\n            app.logger.info(`Generating translation jsons for ${l10nCode}`);\n            const res = generateTranslationJSON(l10nCode, context);\n            const projectReflection = context.project;\n            for(const key in res){\n                const item = res[key];\n                const path = item.projectPath;\n                const obj = getByPath(projectReflection, path);\n                if(obj === undefined){\n                    app.logger.error(`Path not found: ${path}`);\n                }\n            }\n            break;\n        case \"inject\":\n            app.logger.info(`Injecting translation for ${l10nCode}`);\n            injectTranslation(l10nCode, context);\n            break;\n        default:\n            app.logger.info(`Generating translation jsons for ${l10nCode}`);\n            generateTranslationJSON(l10nCode, context);\n            break;\n        }\n    });\n}\n\nfunction injectTranslation(l10nCode: string, context: Context){\n    const curStagingTranslationFile = resolve(`./translations/staging/${l10nCode}`, \"translation.json\");\n    const projectReflection = context.project;\n    const res = dfs(projectReflection, []);\n    if(existsSync(curStagingTranslationFile)){\n        const curStagingTranslation = JSON.parse(readFileSync(curStagingTranslationFile, \"utf-8\")) as TranslationTrimmed;\n        const translationKeys = Object.keys(curStagingTranslation);\n        for (const key of translationKeys){\n            const curStagingItem = curStagingTranslation[key];\n            if(curStagingItem.translation !== \"\" ){\n                const item = getByPathShort(projectReflection, curStagingItem.projectPath);\n                const finalPath = curStagingItem.projectPath[curStagingItem.projectPath.length - 1];\n                if (item !== undefined){\n                    const originalText = getByPath(projectReflection, curStagingItem.projectPath);\n                    if(originalText !== undefined && curStagingItem.originalText == originalText){\n                        item[finalPath] = curStagingItem.translation;\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction generateTranslationJSON(l10nCode: string, context: Context){\n    const curStagingTranslationFile = resolve(`./translations/staging/${l10nCode}`, \"translation.json\");\n    const curProdTranslationFile = resolve(`./translations/prod/${l10nCode}`, \"translation.json\");\n    const projectReflection = context.project;\n    const res = dfs(projectReflection, []);\n    const trimmedDownData = {} as TranslationTrimmed;\n    if(existsSync(curProdTranslationFile)){\n        const curProdTranslation = JSON.parse(readFileSync(curProdTranslationFile, \"utf-8\")) as TranslationTrimmed;\n        const translationKeys = Object.keys(curProdTranslation);\n        for (const key of translationKeys){\n            const curProdItem = curProdTranslation[key];\n            if(curProdItem.translation !== \"\" && curProdItem.translationKey in res && res[curProdItem.translationKey].originalText == curProdItem.originalText){\n                res[curProdItem.translationKey].translation = curProdItem.translation;\n            }\n        }\n    }\n    if(existsSync(curStagingTranslationFile)){\n        const curStagingTranslation = JSON.parse(readFileSync(curStagingTranslationFile, \"utf-8\")) as TranslationTrimmed;\n        const translationKeys = Object.keys(curStagingTranslation);\n        for (const key of translationKeys){\n            const curStagingItem = curStagingTranslation[key];\n            if(curStagingItem.translation !== \"\" && curStagingItem.translationKey in res && res[curStagingItem.translationKey].originalText == curStagingItem.originalText){\n                res[curStagingItem.translationKey].translation = curStagingItem.translation;\n            }\n        }\n    }\n    for(const translationKey in res){\n        const item = res[translationKey];\n        const trimmedItem: TranslationItemTrimmed = {\n            humanReadablePath: item.humanReadablePath,\n            kind: item.kind,\n            originalText: item.originalText,\n            translation: item.translation,\n            projectPath: item.projectPath,\n            translationKey: item.translationKey,\n        };\n        trimmedDownData[translationKey] = trimmedItem;\n    }\n    mkdirSync(`./translations/staging/${l10nCode}`, {recursive: true});\n    writeFileSync(resolve(`./translations/staging/${l10nCode}`, \"translation.json\"), JSON.stringify(trimmedDownData, null, 2));\n    return res;\n}\n\ntype TranslationItem = {\n    originalText: string;\n    translation: string;\n    flatPath: string[];\n    projectPath: string[];\n    locationIdentifier: string;\n    translationKey: string;\n    humanReadablePath?: string;\n    kind: string;\n}\n\ntype TranslationItemTrimmed = {\n    originalText: string;\n    translation: string;\n    projectPath: string[];\n    translationKey: string;\n    humanReadablePath?: string;\n    kind: string;\n}\n\ntype Translation = {\n    [key: string]: TranslationItem;\n}\n\ntype TranslationTrimmed = {\n    [key: string]: TranslationItemTrimmed;\n}\n\nexport function reflectionMapping(node: Reflection){\n    if(node.kind == undefined){\n        return \"unknown\";\n    }\n    switch(node.kind){\n    case reflectionKind.Project:\n        return \"project\";\n    case reflectionKind.Module:\n        return \"module\";\n    case reflectionKind.Namespace:\n        return \"namespace\";\n    case reflectionKind.Enum:\n        return \"enum\";\n    case reflectionKind.EnumMember:\n        return \"enumMember\";\n    case reflectionKind.Variable:\n        return \"variable\";\n    case reflectionKind.Function:\n        return \"function\";\n    case reflectionKind.Class:\n        return \"class\";\n    case reflectionKind.Interface:\n        return \"interface\";\n    case reflectionKind.Constructor:\n        return \"constructor\";\n    case reflectionKind.Property:\n        return \"property\";\n    case reflectionKind.Method:\n        return \"method\";\n    case reflectionKind.CallSignature:\n        return \"callSignature\";\n    case reflectionKind.IndexSignature:\n        return \"indexSignature\";\n    case reflectionKind.ConstructorSignature:\n        return \"constructorSignature\";\n    case reflectionKind.Parameter:\n        return \"parameter\";\n    case reflectionKind.TypeLiteral:\n        return \"typeLiteral\";\n    case reflectionKind.TypeParameter:\n        return \"typeParameter\";\n    case reflectionKind.Accessor:\n        return \"accessor\";\n    case reflectionKind.GetSignature:\n        return \"getSignature\";\n    case reflectionKind.SetSignature:\n        return \"setSignature\";\n    case reflectionKind.TypeAlias:\n        return \"typeAlias\";\n    case reflectionKind.Reference:\n        return \"reference\";\n    default:\n        return \"unknown\";\n    }\n}\n\nexport function getCategoryStrings(node: ProjectReflection, path: string[] = [], humanReadablePath: string[] = []){\n    if (node.categories !== undefined){\n        return node.categories.map((category, index) => {\n            const flatPath = [`${node.id}`, `categories`, `index-${index}`];\n            const projectPath = [...path, \"categories\", `index-${index}`, \"title\"];\n            const translationKey = crypto.createHash('md5').update(`${projectPath.join(\"\")}${category.title}${\"category\"}`).digest('hex');\n            const locationIdentifier = crypto.createHash('md5').update(`${flatPath.join(\"\")}${category.title}${\"category\"}`).digest('hex');\n            const nextLevelHumanReadablePath = [...humanReadablePath, `categories`, `index-${index}`, \"title\"];\n            const item = { translationKey: translationKey, flatPath: flatPath, projectPath: projectPath, originalText: category.title, translation: \"\", kind: \"category\", locationIdentifier: locationIdentifier, humanReadablePath: nextLevelHumanReadablePath.join(\" > \")};\n            return item;\n        });\n    }\n    return undefined;\n}\n\ntype TranslationNode = {\n    [key: string]: Reflection;\n}\n\nfunction dfs(node: Reflection, path: string[] = [], humanReadablePath: string[] = []){\n    const res: Translation = {};\n    if((node.flags && \"isExternal\" in node.flags && node.flags.isExternal)){\n        return res;\n    }\n    if(\"categories\" in node && node.categories !== undefined){\n        const categories = getCategoryStrings(node as ProjectReflection, path, humanReadablePath);\n        if(categories !== undefined){\n            categories.forEach((category)=>{\n                res[category.translationKey] = category;\n            });\n        }\n    }\n    if(node.comment !== undefined){\n        const translations = parseTranslationComment(node, path, humanReadablePath);\n        const translationBlocks = parseTranslationBlockComment(node, path, humanReadablePath);\n        translations.forEach((translation)=>{\n            res[translation.translationKey] = translation;\n        });\n        translationBlocks.forEach((translation)=>{\n            res[translation.translationKey] = translation;\n        });\n    }\n    if(\"children\" in node){\n        const children = node.children as Reflection[];\n        children.forEach((child, index)=>{\n            const localRes = dfs(child, [...path, \"children\", `index-${index}`], [...humanReadablePath, child.name]);\n            const translationKeys = Object.keys(localRes);\n            for (const key of translationKeys){\n                res[key] = localRes[key];\n            }\n        });\n    }\n    if(\"signatures\" in node){\n        const signatures = node.signatures as Reflection[];\n        signatures.forEach((signature, index)=>{\n            const localRes = dfs(signature, [...path, \"signatures\", `index-${index}`], [...humanReadablePath, signature.name]);\n            const translationKeys = Object.keys(localRes);\n            for (const key of translationKeys){\n                res[key] = localRes[key];\n            }\n        });\n    }\n    if(\"getSignature\" in node){\n        const accessorComment = parseAccessorComment(node.getSignature as Reflection, path, node, humanReadablePath);\n        accessorComment.forEach((translationItem)=>{\n            res[translationItem.translationKey] = translationItem;\n        });\n        const getSignature = node.getSignature as Reflection;\n        const localRes = dfs(getSignature, [...path, `getSignature`], [...humanReadablePath, getSignature.name]);\n        const translationKeys = Object.keys(localRes);\n        for (const key of translationKeys){\n            res[key] = localRes[key];\n        }\n    }\n    if(\"setSignature\" in node){\n        const accessorComment = parseAccessorComment(node.setSignature as Reflection, path, node, humanReadablePath);\n        accessorComment.forEach((translationItem)=>{\n            res[translationItem.translationKey] = translationItem;\n        });\n        const setSignature = node.setSignature as Reflection;\n        const localRes = dfs(setSignature, [...path, `setSignature`], [...humanReadablePath, setSignature.name]);\n        const translationKeys = Object.keys(localRes);\n        for (const key of translationKeys){\n            res[key] = localRes[key];\n        }\n    }\n    return res;\n}\n\nfunction parseAccessorComment(node: Reflection, path: string[], parentNode: Reflection, humanReadablePath: string[] = []){\n    const translationItems: TranslationItem[] = [];\n    if (node.comment !== undefined){\n        if(parentNode.comment == undefined){\n            parentNode.comment = new Models.Comment();\n        }\n        node.comment.getTags(\"@accessorDescription\").forEach((comment)=>{\n            comment.content.forEach((content, index)=>{\n                if(content.kind !== \"text\"){\n                    return;\n                }\n                const item: TranslationItem = {\n                        originalText: content.text,\n                        translation: \"\",\n                        flatPath: [],\n                        projectPath: [],\n                        locationIdentifier: \"\",\n                        translationKey: \"\",\n                        kind: \"\"\n                    };\n                item.originalText = content.text;\n                item.translation = \"\";\n                item.flatPath = [];\n                item.flatPath.push(`${node.id}`);\n                item.flatPath.push(`${node.name}`);\n                item.flatPath.push(\"comments\");\n                item.flatPath.push(`index-${index}`);\n                const insertAtSummary = parentNode.comment.summary.length;\n                item.projectPath = [...path, \"comment\", \"summary\",`index-${insertAtSummary}`, \"text\"];\n                parentNode.comment.summary.push({...content});\n                item.kind = reflectionMapping(parentNode);\n                const locationIdentifier = crypto.createHash('md5').update(`${item.flatPath.join(\"\")}${item.originalText}${item.kind}`).digest('hex');\n                item.translationKey = crypto.createHash('md5').update(`${item.projectPath.join(\"\")}${item.originalText}${item.kind}`).digest('hex');\n                item.locationIdentifier = locationIdentifier;\n                item.humanReadablePath = [...humanReadablePath, \"accessor comments\", `index-${index}`, \"text\"].join(\" > \");\n                translationItems.push(item);\n            });\n        });\n        node.comment.removeTags(\"@accessorDescription\");\n    }\n    return translationItems;\n}\n\nfunction parseTranslationComment(node: Reflection, path: string[], humanReadablePath: string[] = []){\n    const translationItems: TranslationItem[] = [];\n    if (node.comment !== undefined){\n        node.comment.getTags(\"@translation\").forEach((comment)=>{\n            comment.content.forEach((content, index)=>{\n                if(content.kind !== \"text\"){\n                    return;\n                }\n                const item: TranslationItem = {\n                        originalText: content.text,\n                        translation: \"\",\n                        flatPath: [],\n                        projectPath: [],\n                        locationIdentifier: \"\",\n                        translationKey: \"\",\n                        kind: \"\"\n                    };\n                item.originalText = content.text;\n                item.translation = \"\";\n                item.flatPath = [];\n                item.flatPath.push(`${node.id}`);\n                item.flatPath.push(`${node.name}`);\n                item.flatPath.push(\"comments\");\n                item.flatPath.push(`index-${index}`);\n                const insertAtSummary = node.comment.summary.length;\n                item.projectPath = [...path, \"comment\", \"summary\",`index-${insertAtSummary}`, \"text\"];\n                node.comment.summary.push({...content});\n                item.kind = reflectionMapping(node);\n                const locationIdentifier = crypto.createHash('md5').update(`${item.flatPath.join(\"\")}${item.originalText}${item.kind}`).digest('hex');\n                item.translationKey = crypto.createHash('md5').update(`${item.projectPath.join(\"\")}${item.originalText}${item.kind}`).digest('hex');\n                item.locationIdentifier = locationIdentifier;\n                item.humanReadablePath = [...humanReadablePath, \"translation comments\", `index-${index}`, \"text\"].join(\" > \");\n                translationItems.push(item);\n            });\n        });\n        node.comment.removeTags(\"@translation\");\n    }\n    return translationItems;\n}\n\nfunction parseTranslationBlockComment(node: Reflection, path: string[], humanReadablePath: string[] = []){\n    const translationItems: TranslationItem[] = [];\n    if (node.comment !== undefined){\n        node.comment.blockTags.forEach((comment, blockIndex)=>{\n            if(comment.tag !== \"@translationBlock\"){\n                return;\n            }\n            comment.content.forEach((content, index)=>{\n                if(content.kind !== \"text\"){\n                    return;\n                }\n                const item: TranslationItem = {\n                    originalText: content.text,\n                    translation: \"\",\n                    flatPath: [],\n                    projectPath: [],\n                    locationIdentifier: \"\",\n                    translationKey: \"\",\n                    kind: \"\"\n                };\n                item.originalText = content.text;\n                item.translation = \"\";\n                item.flatPath = [];\n                item.flatPath.push(`${node.id}`);\n                item.flatPath.push(`${node.name}`);\n                item.flatPath.push(\"comments\");\n                item.flatPath.push(`index-${index}`);\n                item.projectPath = [...path, \"comment\", \"blockTags\",`index-${blockIndex}`, \"content\", `index-${index}`, \"text\"];\n                // const insertAtSummary = node.comment.summary.length;\n                // node.comment.summary.push(content);\n                item.kind = reflectionMapping(node);\n                const locationIdentifier = crypto.createHash('md5').update(`${item.flatPath.join(\"\")}${item.originalText}${item.kind}`).digest('hex');\n                item.translationKey = crypto.createHash('md5').update(`${item.projectPath.join(\"\")}${item.originalText}${item.kind}`).digest('hex');\n                item.locationIdentifier = locationIdentifier;\n                item.humanReadablePath = [...humanReadablePath, \"translation block comments\", `index-${index}`, \"text\"].join(\" > \");\n                translationItems.push(item);\n            });\n        });\n    }\n    return translationItems;\n}\n\nfunction reflectionClassMapping(reflection: Reflection){\n    switch(reflection.constructor.name){\n    case \"ProjectReflection\":\n        return \"project\";\n    case \"ContainerReflection\":\n        return \"container\";\n    case \"DeclarationReflection\":\n        return \"declaration\";\n    case \"ParameterReflection\":\n        return \"parameter\";\n    case \"ReferenceReflection\":\n        return \"reference\";\n    case \"TypeParameterReflection\":\n        return \"typeParameter\";\n    case \"SignatureReflection\":\n        return \"signature\";\n    default:\n        return \"reflection\";\n    }\n}\n\nexport function getByPathShort(root: any, path: string[]){\n    let obj = root;\n    for(let index = 0; index < path.length - 1; index++){\n        if(obj === undefined){\n            console.error(\"Path not found\", path);\n            return undefined;\n        }\n        if(path[index].length >= 5 && path[index].substring(0, 5) === \"index\"){\n            const indexInPath = parseInt(path[index].substring(6));\n            obj = obj[indexInPath];\n            continue;\n        }\n        if(path[index] in obj){\n            const propertyName = path[index];\n            obj = obj[propertyName];\n        }\n    }\n    return obj;\n}\n\nexport function getByPath(root: any, path: string[]){\n    let obj = root;\n    for(let index = 0; index < path.length; index++){\n        if(obj === undefined){\n            console.error(\"Path not found\", path);\n            return undefined;\n        }\n        if(path[index].length >= 5 && path[index].substring(0, 5) === \"index\"){\n            const indexInPath = parseInt(path[index].substring(6));\n            obj = obj[indexInPath];\n            continue;\n        }\n        obj = obj[path[index]];\n    }\n    return obj;\n}\n"],"names":["reflectionKind","ReflectionKind","generateTranslationJSON","l10nCode","context","curStagingTranslationFile","resolve","curProdTranslationFile","res","dfs","project","trimmedDownData","existsSync","curProdTranslation","JSON","parse","readFileSync","translationKeys","Object","keys","key","curProdItem","translation","translationKey","originalText","curStagingTranslation","curStagingItem","item","trimmedItem","humanReadablePath","kind","projectPath","mkdirSync","recursive","writeFileSync","stringify","reflectionMapping","node","undefined","Project","Module","Namespace","Enum","EnumMember","Variable","Function","Class","Interface","Constructor","Property","Method","CallSignature","IndexSignature","ConstructorSignature","Parameter","TypeLiteral","TypeParameter","Accessor","GetSignature","SetSignature","TypeAlias","Reference","getCategoryStrings","path","categories","map","category","index","flatPath","id","crypto","createHash","update","join","title","digest","locationIdentifier","nextLevelHumanReadablePath","flags","isExternal","forEach","comment","translations","translationItems","getTags","content","text","push","name","insertAtSummary","summary","length","assign","removeTags","parseTranslationComment","translationBlocks","blockTags","blockIndex","tag","parseTranslationBlockComment","children","child","localRes","signatures","signature","parseAccessorComment","getSignature","translationItem","setSignature","parentNode","Models","Comment","getByPathShort","root","obj","console","error","substring","parseInt","getByPath","app","options","addDeclaration","help","type","ParameterType","String","defaultValue","converter","on","Converter","EVENT_END","getValue","logger","info","projectReflection","finalPath","injectTranslation"],"mappings":"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"}